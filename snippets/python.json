{
  "add_binary_strings": {
    "description": "Add two binary strings and return the result as a binary string, useful for low-level programming.",
    "code": "def add_binary_strings(a, b):\n    return bin(int(a, 2) + int(b, 2))[2:]"
  },
  "angular_velocity": {
    "description": "Calculate angular velocity using omega = theta / t (physics).",
    "code": "def angular_velocity(theta, t):\n    return theta / t"
  },
  "avogadro_number": {
    "description": "Calculate the number of particles using N = n * NA (chemistry).",
    "code": "def avogadro_number(moles, NA=6.02214076e23):\n    return moles * NA"
  },
  "balance_equation": {
    "description": "Balance a simple chemical equation (e.g., 'H2 + O2 -> H2O') by returning coefficients.",
    "code": "def balance_equation(equation):\n    reactants, products = equation.split(' -> ')\n    if reactants == 'H2 + O2' and products == 'H2O':\n        return {'H2': 2, 'O2': 1, 'H2O': 2}\n    return 'Only H2 + O2 -> H2O is supported'"
  },
  "base64_decode": {
    "description": "Decode a Base64 string, useful for mobile app data transfer.",
    "code": "import base64\n\ndef base64_decode(s):\n    return base64.b64decode(s.encode()).decode()"
  },
  "base64_encode": {
    "description": "Encode a string to Base64, useful for mobile app data transfer.",
    "code": "import base64\n\ndef base64_encode(s):\n    return base64.b64encode(s.encode()).decode()"
  },
  "batch_process": {
    "description": "Process a list in batches with a custom function.",
    "code": "def batch_process(lst, batch_size, process_func):\n results = []\n for i in range(0, len(lst), batch_size):\n batch = lst[i:i + batch_size]\n results.extend(process_func(batch))\n return results"
  },
  "binary_search": {
    "description": "Perform binary search on a sorted array.",
    "code": "def binary_search(arr, target):\n left, right = 0, len(arr) - 1\n while left <= right:\n mid = (left + right) // 2\n if arr[mid] == target:\n return mid\n elif arr[mid] < target:\n left = left + 1\n else:\n right = right - 1\n return -1"
  },
  "binary_to_decimal": {
    "description": "Convert a binary string to decimal number.",
    "code": "def binary_to_decimal(binary):\n    return int(binary, 2)"
  },
  "bit_count": {
    "description": "Count the number of 1s in the binary representation of a number, useful for low-level programming.",
    "code": "def bit_count(n):\n    return bin(n).count('1')"
  },
  "bit_flip": {
    "description": "Flip all bits in a number (0 to 1, 1 to 0), useful for low-level programming.",
    "code": "def bit_flip(n, bits=32):\n    return n ^ ((1 << bits) - 1)"
  },
  "bitwise_and": {
    "description": "Perform a bitwise AND operation, useful for low-level programming like assembly.",
    "code": "def bitwise_and(a, b):\n    return a & b"
  },
  "bitwise_not": {
    "description": "Perform a bitwise NOT operation on a number, useful for low-level programming.",
    "code": "def bitwise_not(a):\n    return ~a"
  },
  "bitwise_or": {
    "description": "Perform a bitwise OR operation, useful for low-level programming like assembly.",
    "code": "def bitwise_or(a, b):\n    return a | b"
  },
  "bitwise_xor": {
    "description": "Perform a bitwise XOR operation, useful for low-level programming like assembly.",
    "code": "def bitwise_xor(a, b):\n    return a ^ b"
  },
  "boiling_point_elevation": {
    "description": "Calculate boiling point elevation using delta_T = Kb * m (chemistry).",
    "code": "def boiling_point_elevation(kb, m):\n    return kb * m"
  },
  "byte_to_bits": {
    "description": "Convert a byte (integer 0-255) to its 8-bit binary string representation.",
    "code": "def byte_to_bits(byte):\n    return format(byte, '08b')"
  },
  "calculate_distance": {
    "description": "Calculate the Euclidean distance between two points, useful for gaming.",
    "code": "def calculate_distance(x1, y1, x2, y2):\n    return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5"
  },
  "camel_to_snake": {
    "description": "Convert a camelCase string to snake_case.",
    "code": "def camel_to_snake(s):\n    result = ''\n    for i, char in enumerate(s):\n        if char.isupper() and i > 0:\n            result += '_'\n        result += char.lower()\n    return result"
  },
  "capacitance": {
    "description": "Calculate capacitance using C = Q / V (physics).",
    "code": "def capacitance(q, v):\n    return q / v"
  },
  "centripetal_force": {
    "description": "Calculate centripetal force using F = m * v^2 / r (physics).",
    "code": "def centripetal_force(m, v, r):\n    return m * v * v / r"
  },
  "check_even_odd": {
    "description": "Check if a number is even or odd using bitwise operations, inspired by assembly.",
    "code": "def check_even_odd(n):\n    return 'even' if (n & 1) == 0 else 'odd'"
  },
  "check_palindrome": {
    "description": "Check if a string is a palindrome.",
    "code": "def is_palindrome(s):\n return s == s[::-1]"
  },
  "chunk_list": {
    "description": "Split a list into chunks of a specified size.",
    "code": "def chunk_list(lst, chunk_size):\n for i in range(0, len(lst), chunk_size):\n yield lst[i:i + chunk_size]"
  },
  "clear_bit": {
    "description": "Clear a specific bit in a number to 0, useful for low-level programming.",
    "code": "def clear_bit(n, position):\n    return n & ~(1 << position)"
  },
  "collision_detection": {
    "description": "Check for collision between two rectangles, useful for gaming.",
    "code": "def collision_detection(rect1, rect2):\n    x1, y1, w1, h1 = rect1\n    x2, y2, w2, h2 = rect2\n    return (x1 < x2 + w2 and x1 + w1 > x2 and y1 < y2 + h2 and y1 + h1 > y2)"
  },
  "combination": {
    "description": "Calculate the number of combinations C(n, k).",
    "code": "def combination(n, k):\n    if k > n:\n        return 0\n    if k == 0:\n        return 1\n    k = min(k, n - k)\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c"
  },
  "count_char_frequency": {
    "description": "Count the frequency of each character in a string.",
    "code": "from collections import Counter\nfrequency = Counter(my_string)"
  },
  "count_words": {
    "description": "Count the frequency of each word in a string.",
    "code": "def count_words(s):\n words = s.split()\n freq = {}\n for word in words:\n freq[word] = freq.get(word, 0) + 1\n return freq"
  },
  "coulomb_force": {
    "description": "Calculate Coulomb force between two charges using F = k * |q1 * q2| / r^2 (physics).",
    "code": "def coulomb_force(q1, q2, r, k=8.9875517923e9):\n    return k * abs(q1 * q2) / (r * r)"
  },
  "csv_to_dict": {
    "description": "Convert a CSV file to a list of dictionaries.",
    "code": "import csv\n\ndef csv_to_dict(file_path):\n with open(file_path, 'r') as file:\n return list(csv.DictReader(file))"
  },
  "csv_to_list": {
    "description": "Read a CSV file into a list of lists.",
    "code": "import csv\n\ndef csv_to_list(file_path):\n    with open(file_path, 'r') as file:\n        return list(csv.reader(file))"
  },
  "date_difference": {
    "description": "Calculate the difference between two dates.",
    "code": "from datetime import datetime\n\ndef date_difference(date1, date2, format='%Y-%m-%d'):\n d1 = datetime.strptime(date1, format)\n d2 = datetime.strptime(date2, format)\n return abs((d2 - d1).days)"
  },
  "days_between_dates": {
    "description": "Calculate the number of days between two dates using datetime.",
    "code": "from datetime import datetime\n\ndef days_between_dates(date1, date2):\n d1 = datetime.strptime(date1, '%Y-%m-%d')\n d2 = datetime.strptime(date2, '%Y-%m-%d')\n return abs((d2 - d1).days)"
  },
  "decimal_to_binary": {
    "description": "Convert a decimal number to binary string.",
    "code": "def decimal_to_binary(n):\n    if n == 0:\n        return '0'\n    return bin(n)[2:]"
  },
  "decimal_to_hex": {
    "description": "Convert a decimal number to hexadecimal string (without '0x' prefix).",
    "code": "def decimal_to_hex(n):\n    if n == 0:\n        return '0'\n    return hex(n)[2:]"
  },
  "decimal_to_octal": {
    "description": "Convert a decimal number to octal string.",
    "code": "def decimal_to_octal(n):\n    if n == 0:\n        return '0'\n    return oct(n)[2:]"
  },
  "deep_copy": {
    "description": "Create a deep copy of a list or dictionary using recursion.",
    "code": "def deep_copy(obj):\n if isinstance(obj, list):\n return [deep_copy(item) for item in obj]\n elif isinstance(obj, dict):\n return {key: deep_copy(value) for key, value in obj.items()}\n else:\n return obj"
  },
  "derivative": {
    "description": "Approximate the derivative of a function at a point using central difference.",
    "code": "def derivative(f, x, h=1e-5):\n    return (f(x + h) - f(x - h)) / (2 * h)"
  },
  "determinant_2x2": {
    "description": "Calculate the determinant of a 2x2 matrix.",
    "code": "def determinant_2x2(mat):\n    return mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0]"
  },
  "determinant_3x3": {
    "description": "Calculate the determinant of a 3x3 matrix using cofactor expansion.",
    "code": "def determinant_3x3(mat):\n    return (mat[0][0] * (mat[1][1] * mat[2][2] - mat[1][2] * mat[2][1]) -\n            mat[0][1] * (mat[1][0] * mat[2][2] - mat[1][2] * mat[2][0]) +\n            mat[0][2] * (mat[1][0] * mat[2][1] - mat[1][1] * mat[2][0]))"
  },
  "dict_to_json_file": {
    "description": "Write a dictionary to a JSON file.",
    "code": "import json\n\ndef dict_to_json_file(data, file_path):\n with open(file_path, 'w') as file:\n json.dump(data, file, indent=4)"
  },
  "displacement": {
    "description": "Calculate displacement using s = ut + (1/2)at^2 (physics kinematics).",
    "code": "def displacement(u, a, t):\n    return u * t + 0.5 * a * t * t"
  },
  "electric_field": {
    "description": "Calculate electric field using E = k * q / r^2 (physics).",
    "code": "def electric_field(q, r, k=8.9875517923e9):\n    return k * q / (r * r)"
  },
  "equilibrium_constant": {
    "description": "Calculate the equilibrium constant Kc for a reaction aA + bB -> cC + dD.",
    "code": "def equilibrium_constant(c_C, c_D, c_A, c_B, a, b, c, d):\n    return (c_C ** c * c_D ** d) / (c_A ** a * c_B ** b)"
  },
  "euler_totient": {
    "description": "Calculate Euler's totient function for a number, counting numbers coprime to n.",
    "code": "def euler_totient(n):\n    result = n\n    p = 2\n    while p * p <= n:\n        if n % p == 0:\n            while n % p == 0:\n                n //= p\n            result -= result // p\n        p += 1\n    if n > 1:\n        result -= result // n\n    return result"
  },
  "extract_digits": {
    "description": "Extract all digits from a string into a list.",
    "code": "def extract_digits(s):\n return [int(d) for d in s if d.isdigit()]"
  },
  "factorial": {
    "description": "Calculate the factorial of a number.",
    "code": "def factorial(n):\n if n == 0:\n return 1\n else:\n return n * factorial(n-1)"
  },
  "factory_pattern": {
    "description": "Implement a factory pattern for creating objects in OOP.",
    "code": "class Shape:\n    def draw(self):\n        pass\n\nclass Circle(Shape):\n    def draw(self):\n        return 'Drawing a circle'\n\nclass Square(Shape):\n    def draw(self):\n        return 'Drawing a square'\n\ndef shape_factory(shape_type):\n    shapes = {'circle': Circle, 'square': Square}\n    return shapes[shape_type]() if shape_type in shapes else None"
  },
  "fibonacci_sequence": {
    "description": "Generate the Fibonacci sequence up to n terms.",
    "code": "def fibonacci(n):\n a, b = 0, 1\n for _ in range(n):\n yield a\n a, b = b, a + b"
  },
  "find_all_substrings": {
    "description": "Find all occurrences of a substring in a string.",
    "code": "def find_all_substrings(string, sub):\n start = 0\n while True:\n start = string.find(sub, start)\n if start == -1:\n return\n yield start\n start += 1"
  },
  "find_common_elements": {
    "description": "Find common elements between two lists.",
    "code": "def find_common_elements(list1, list2):\n return list(set(list1) & set(list2))"
  },
  "find_duplicates": {
    "description": "Find duplicates in a list using only standard library.",
    "code": "def find_duplicates(lst):\n seen = set()\n duplicates = set()\n for item in lst:\n if item in seen:\n duplicates.add(item)\n else:\n seen.add(item)\n return list(duplicates)"
  },
  "find_file_in_dir": {
    "description": "Find all files with a specific extension in a directory.",
    "code": "import os\n\ndef find_file_in_dir(directory, extension):\n    return [f for f in os.listdir(directory) if f.endswith(extension)]"
  },
  "find_missing_numbers": {
    "description": "Find missing numbers in a list within a range.",
    "code": "def find_missing_numbers(lst, start, end):\n    return [num for num in range(start, end + 1) if num not in lst]"
  },
  "flatten_list": {
    "description": "Flatten a nested list into a single-level list.",
    "code": "def flatten_list(nested_list):\n flat_list = []\n for item in nested_list:\n if isinstance(item, list):\n flat_list.extend(flatten_list(item))\n else:\n flat_list.append(item)\n return flat_list"
  },
  "format_date": {
    "description": "Format a date in a specific way.",
    "code": "from datetime import datetime\n\ndef format_date(date, input_format='%Y-%m-%d', output_format='%d/%m/%Y'):\n d = datetime.strptime(date, input_format)\n return d.strftime(output_format)"
  },
  "frame_rate_limiter": {
    "description": "Limit the frame rate in a game loop to control speed.",
    "code": "import time\n\ndef frame_rate_limiter(target_fps):\n    frame_time = 1 / target_fps\n    last_time = time.time()\n    def limiter():\n        nonlocal last_time\n        current_time = time.time()\n        sleep_time = frame_time - (current_time - last_time)\n        if sleep_time > 0:\n            time.sleep(sleep_time)\n        last_time = time.time()\n    return limiter"
  },
  "freezing_point_depression": {
    "description": "Calculate freezing point depression using delta_T = Kf * m (chemistry).",
    "code": "def freezing_point_depression(kf, m):\n    return kf * m"
  },
  "frequency": {
    "description": "Calculate frequency using f = 1 / T (physics).",
    "code": "def frequency(period):\n    return 1 / period"
  },
  "gaussian_elimination": {
    "description": "Solve a system of linear equations using Gaussian elimination.",
    "code": "def gaussian_elimination(A, b):\n    n = len(A)\n    for i in range(n):\n        pivot = A[i][i]\n        for j in range(i + 1, n):\n            factor = A[j][i] / pivot\n            for k in range(i, n):\n                A[j][k] -= factor * A[i][k]\n            b[j] -= factor * b[i]\n    x = [0] * n\n    for i in range(n - 1, -1, -1):\n        x[i] = (b[i] - sum(A[i][j] * x[j] for j in range(i + 1, n))) / A[i][i]\n    return x"
  },
  "gcd": {
    "description": "Calculate the greatest common divisor using Euclid's algorithm.",
    "code": "def gcd(a, b):\n while b:\n a, b = b, a % b\n return a"
  },
  "generate_combinations": {
    "description": "Generate all combinations of a list of a given size using recursion.",
    "code": "def generate_combinations(arr, r):\n if r == 0:\n return [[]]\n if r > len(arr):\n return []\n combs = []\n for i in range(len(arr)):\n for c in generate_combinations(arr[i+1:], r-1):\n combs.append([arr[i]] + c)\n return combs"
  },
  "generate_permutations": {
    "description": "Generate all permutations of a list using recursion.",
    "code": "def generate_permutations(arr):\n if len(arr) <= 1:\n return [arr]\n perms = []\n for i in range(len(arr)):\n rest = arr[:i] + arr[i+1:]\n for p in generate_permutations(rest):\n perms.append([arr[i]] + p)\n return perms"
  },
  "generate_uuid": {
    "description": "Generate a random UUID string.",
    "code": "import uuid\n\ndef generate_uuid():\n    return str(uuid.uuid4())"
  },
  "get_bit": {
    "description": "Get the value of a specific bit in a number (0 or 1), useful for low-level programming.",
    "code": "def get_bit(n, position):\n    return (n >> position) & 1"
  },
  "get_file_size": {
    "description": "Get the size of a file in bytes.",
    "code": "import os\n\ndef get_file_size(file_path):\n    return os.path.getsize(file_path)"
  },
  "gravitational_force": {
    "description": "Calculate gravitational force between two masses using F = G * (m1 * m2) / r^2 (physics).",
    "code": "def gravitational_force(m1, m2, r, G=6.67430e-11):\n    return G * (m1 * m2) / (r * r)"
  },
  "group_by_key": {
    "description": "Group a list of dictionaries by a specific key.",
    "code": "from collections import defaultdict\n\ndef group_by_key(lst, key):\n grouped = defaultdict(list)\n for item in lst:\n grouped[item[key]].append(item)\n return dict(grouped)"
  },
  "half_life": {
    "description": "Calculate the half-life of a substance using t_half = ln(2) / k (chemistry).",
    "code": "def half_life(k):\n    import math\n    return math.log(2) / k"
  },
  "hash_password": {
    "description": "Hash a password using SHA-256 for secure storage.",
    "code": "import hashlib\n\ndef hash_password(password):\n    return hashlib.sha256(password.encode()).hexdigest()"
  },
  "hex_to_decimal": {
    "description": "Convert a hexadecimal string to decimal number.",
    "code": "def hex_to_decimal(hex_str):\n    return int(hex_str, 16)"
  },
  "human_readable_size": {
    "description": "Convert bytes to a human-readable size (e.g., KB, MB).",
    "code": "def human_readable_size(size_bytes):\n for unit in ['B', 'KB', 'MB', 'GB', 'TB']:\n if size_bytes < 1024:\n return f'{size_bytes:.2f} {unit}'\n size_bytes /= 1024\n return f'{size_bytes:.2f} PB'"
  },
  "hydrogen_from_ph": {
    "description": "Calculate hydrogen ion concentration from pH (chemistry).",
    "code": "def hydrogen_from_ph(ph):\n    import math\n    return 10 ** (-ph)"
  },
  "ideal_gas_law": {
    "description": "Calculate pressure using the ideal gas law P = nRT / V (chemistry).",
    "code": "def ideal_gas_law(n, T, V, R=8.314):\n    return (n * R * T) / V"
  },
  "integrate_simpson": {
    "description": "Approximate the definite integral of a function using Simpson's rule.",
    "code": "def integrate_simpson(f, a, b, n):\n    if n % 2 != 0:\n        raise ValueError('n must be even')\n    h = (b - a) / n\n    result = f(a) + f(b)\n    for i in range(1, n, 2):\n        result += 4 * f(a + i * h)\n    for i in range(2, n - 1, 2):\n        result += 2 * f(a + i * h)\n    return result * h / 3"
  },
  "inverse_2x2": {
    "description": "Calculate the inverse of a 2x2 matrix if it exists.",
    "code": "def inverse_2x2(mat):\n    det = mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0]\n    if det == 0:\n        raise ValueError('Matrix is not invertible')\n    inv_det = 1 / det\n    return [[mat[1][1] * inv_det, -mat[0][1] * inv_det], [-mat[1][0] * inv_det, mat[0][0] * inv_det]]"
  },
  "invert_dict": {
    "description": "Invert a dictionary, mapping values to keys (assumes unique values).",
    "code": "def invert_dict(d):\n return {v: k for k, v in d.items()}"
  },
  "is_anagram": {
    "description": "Check if two strings are anagrams.",
    "code": "def is_anagram(s1, s2):\n return sorted(s1) == sorted(s2)"
  },
  "is_leap_year": {
    "description": "Check if a year is a leap year.",
    "code": "def is_leap_year(year):\n if year % 4 != 0:\n return False\n elif year % 100 != 0:\n return True\n elif year % 400 != 0:\n return False\n else:\n return True"
  },
  "is_perfect_number": {
    "description": "Check if a number is perfect (sum of proper divisors equals the number).",
    "code": "def is_perfect_number(n):\n divisors_sum = sum(i for i in range(1, n) if n % i == 0)\n return divisors_sum == n"
  },
  "is_power_of_two": {
    "description": "Check if a number is a power of 2 using bitwise operations, useful for low-level programming.",
    "code": "def is_power_of_two(n):\n    return n > 0 and (n & (n - 1)) == 0"
  },
  "is_prime": {
    "description": "Check if a number is prime, useful for mathematical computations.",
    "code": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"
  },
  "is_subset": {
    "description": "Check if one list is a subset of another.",
    "code": "def is_subset(list1, list2):\n    return all(item in list2 for item in list1)"
  },
  "iterate_two_lists": {
    "description": "Iterate over two lists simultaneously using zip.",
    "code": "for item1, item2 in zip(list1, list2):\n print(item1, item2)"
  },
  "json_to_query": {
    "description": "Convert a dictionary to a URL query string for mobile API requests.",
    "code": "from urllib.parse import urlencode\n\ndef json_to_query(data):\n    return urlencode(data)"
  },
  "kinetic_energy": {
    "description": "Calculate kinetic energy using KE = (1/2)mv^2 (physics).",
    "code": "def kinetic_energy(m, v):\n    return 0.5 * m * v * v"
  },
  "lcm": {
    "description": "Calculate the least common multiple of two numbers using gcd.",
    "code": "def gcd(a, b):\n while b:\n a, b = b, a % b\n return a\n\ndef lcm(a, b):\n return abs(a * b) // gcd(a, b) if a and b else 0"
  },
  "linear_interpolation": {
    "description": "Perform linear interpolation between two points (x0, y0) and (x1, y1) at point x.",
    "code": "def linear_interpolation(x0, y0, x1, y1, x):\n    return y0 + (y1 - y0) * (x - x0) / (x1 - x0)"
  },
  "linear_search_multiple": {
    "description": "Find all indices of a target value in a list.",
    "code": "def linear_search_multiple(arr, target):\n return [i for i, x in enumerate(arr) if x == target]"
  },
  "list_to_dict": {
    "description": "Convert two lists into a dictionary (keys and values).",
    "code": "def list_to_dict(keys, values):\n return dict(zip(keys, values))"
  },
  "log_to_file": {
    "description": "Log messages to a file with timestamps for debugging.",
    "code": "from datetime import datetime\n\ndef log_to_file(message, filename='log.txt'):\n    with open(filename, 'a') as f:\n        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n        f.write(f'[{timestamp}] {message}\\n')"
  },
  "loop_reverse": {
    "description": "Loop over a list in reverse.",
    "code": "for item in reversed(my_list):\n print(item)"
  },
  "loop_with_index": {
    "description": "Loop over a list with an index using enumerate.",
    "code": "for index, item in enumerate(my_list):\n print(index, item)"
  },
  "mass_to_mole": {
    "description": "Convert mass to moles using moles = mass / molar_mass (chemistry).",
    "code": "def mass_to_mole(mass, molar_mass):\n    return mass / molar_mass"
  },
  "matrix_add": {
    "description": "Add two matrices of the same dimensions, useful for mathematical computations.",
    "code": "def matrix_add(mat1, mat2):\n    return [[mat1[i][j] + mat2[i][j] for j in range(len(mat1[0]))] for i in range(len(mat1))]"
  },
  "matrix_multiply": {
    "description": "Multiply two matrices, useful for mathematical computations.",
    "code": "def matrix_multiply(mat1, mat2):\n    result = [[0 for _ in range(len(mat2[0]))] for _ in range(len(mat1))]\n    for i in range(len(mat1)):\n        for j in range(len(mat2[0])):\n            for k in range(len(mat2)):\n                result[i][j] += mat1[i][k] * mat2[k][j]\n    return result"
  },
  "matrix_subtract": {
    "description": "Subtract two matrices of the same dimensions, useful for mathematical computations.",
    "code": "def matrix_subtract(mat1, mat2):\n    return [[mat1[i][j] - mat2[i][j] for j in range(len(mat1[0]))] for i in range(len(mat1))]"
  },
  "matrix_transpose": {
    "description": "Transpose a matrix (swap rows and columns).",
    "code": "def transpose_matrix(matrix):\n return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]"
  },
  "memoize": {
    "description": "Create a memoization decorator for caching function results.",
    "code": "def memoize(func):\n    cache = {}\n    def wrapper(*args):\n        if args in cache:\n            return cache[args]\n        result = func(*args)\n        cache[args] = result\n        return result\n    return wrapper"
  },
  "merge_sorted_lists": {
    "description": "Merge two sorted lists into a single sorted list.",
    "code": "def merge_sorted_lists(list1, list2):\n merged = []\n i, j = 0, 0\n while i < len(list1) and j < len(list2):\n if list1[i] <= list2[j]:\n merged.append(list1[i])\n i += 1\n else:\n merged.append(list2[j])\n j += 1\n merged.extend(list1[i:])\n merged.extend(list2[j:])\n return merged"
  },
  "merge_two_dicts": {
    "description": "Merge two dictionaries, with the second overriding the first.",
    "code": "def merge_two_dicts(dict1, dict2):\n return {**dict1, **dict2}"
  },
  "molality": {
    "description": "Calculate molality using m = moles / mass_of_solvent (chemistry).",
    "code": "def molality(moles, mass_of_solvent):\n    return moles / mass_of_solvent"
  },
  "molar_mass": {
    "description": "Calculate the molar mass of a compound given its formula (e.g., 'H2O'), useful in chemistry.",
    "code": "def molar_mass(formula):\n    atomic_masses = {'H': 1.008, 'O': 15.999, 'C': 12.011, 'N': 14.007}\n    mass = 0\n    element = ''\n    number = ''\n    for char in formula + ' ':\n        if char.isalpha():\n            if element:\n                count = int(number) if number else 1\n                mass += atomic_masses.get(element, 0) * count\n            element = char\n            number = ''\n        elif char.isdigit():\n            number += char\n    return mass"
  },
  "molarity": {
    "description": "Calculate molarity using M = moles / volume (chemistry).",
    "code": "def molarity(moles, volume):\n    return moles / volume"
  },
  "mole_to_mass": {
    "description": "Convert moles to mass using mass = moles * molar_mass (chemistry).",
    "code": "def mole_to_mass(moles, molar_mass):\n    return moles * molar_mass"
  },
  "momentum": {
    "description": "Calculate momentum using p = mv (physics).",
    "code": "def momentum(m, v):\n    return m * v"
  },
  "nested_dict_update": {
    "description": "Update a nested dictionary with new values recursively.",
    "code": "def nested_dict_update(d, u):\n for k, v in u.items():\n if isinstance(v, dict):\n d[k] = nested_dict_update(d.get(k, {}), v)\n else:\n d[k] = v\n return d"
  },
  "newton_raphson": {
    "description": "Find a root of a function using the Newton-Raphson method.",
    "code": "def newton_raphson(f, df, x0, tol=1e-6, max_iter=100):\n    x = x0\n    for _ in range(max_iter):\n        fx = f(x)\n        if abs(fx) < tol:\n            return x\n        dfx = df(x)\n        if dfx == 0:\n            raise ValueError('Derivative is zero')\n        x -= fx / dfx\n    return x"
  },
  "nth_prime": {
    "description": "Find the nth prime number, useful for mathematical computations.",
    "code": "def nth_prime(n):\n    if n < 1:\n        raise ValueError('n must be positive')\n    count = 0\n    num = 1\n    while count < n:\n        num += 1\n        if all(num % i != 0 for i in range(2, int(num ** 0.5) + 1)):\n            count += 1\n    return num"
  },
  "observer_pattern": {
    "description": "Implement an observer pattern for event handling in OOP.",
    "code": "class Subject:\n    def __init__(self):\n        self._observers = []\n\n    def attach(self, observer):\n        self._observers.append(observer)\n\n    def notify(self):\n        for observer in self._observers:\n            observer.update()\n\nclass Observer:\n    def update(self):\n        print('Observer updated')"
  },
  "octal_to_decimal": {
    "description": "Convert an octal string to decimal number.",
    "code": "def octal_to_decimal(octal):\n    return int(octal, 8)"
  },
  "osmotic_pressure": {
    "description": "Calculate osmotic pressure using pi = MRT (chemistry).",
    "code": "def osmotic_pressure(molarity, T, R=8.314):\n    return molarity * R * T"
  },
  "parallel_resistance": {
    "description": "Calculate total resistance in a parallel circuit (physics).",
    "code": "def parallel_resistance(resistors):\n    return 1 / sum(1 / r for r in resistors)"
  },
  "parse_ini_file": {
    "description": "Parse a simple INI configuration file into a dictionary.",
    "code": "def parse_ini_file(file_path):\n    config = {}\n    with open(file_path, 'r') as f:\n        current_section = ''\n        for line in f:\n            line = line.strip()\n            if not line or line.startswith('#'):\n                continue\n            if line.startswith('[') and line.endswith(']'):\n                current_section = line[1:-1]\n                config[current_section] = {}\n            else:\n                key, value = line.split('=', 1)\n                config[current_section][key.strip()] = value.strip()\n    return config"
  },
  "parse_query_string": {
    "description": "Parse a URL query string into a dictionary.",
    "code": "def parse_query_string(query):\n from urllib.parse import parse_qs\n return {k: v[0] if len(v) == 1 else v for k, v in parse_qs(query).items()}"
  },
  "pascal_triangle": {
    "description": "Generate Pascal's triangle up to n rows.",
    "code": "def pascal_triangle(n):\n triangle = [[1]]\n for i in range(1, n):\n prev_row = triangle[-1]\n new_row = [1] + [prev_row[j-1] + prev_row[j] for j in range(1, i)] + [1]\n triangle.append(new_row)\n return triangle"
  },
  "pattern_triangle": {
    "description": "Generate a triangle pattern of numbers.",
    "code": "def print_triangle(n):\n for i in range(1, n + 1):\n print(' '.join(str(j) for j in range(1, i + 1)))"
  },
  "percent_composition": {
    "description": "Calculate the percent composition of an element in a compound (chemistry).",
    "code": "def percent_composition(element_mass, total_mass):\n    return (element_mass / total_mass) * 100"
  },
  "permutation": {
    "description": "Calculate the number of permutations P(n, k).",
    "code": "def permutation(n, k):\n    if k > n:\n        return 0\n    p = 1\n    for i in range(n - k + 1, n + 1):\n        p *= i\n    return p"
  },
  "ph_from_hydrogen": {
    "description": "Calculate pH from hydrogen ion concentration (chemistry).",
    "code": "def ph_from_hydrogen(h_concentration):\n    import math\n    return -math.log10(h_concentration)"
  },
  "photon_energy": {
    "description": "Calculate photon energy using E = h * f (physics).",
    "code": "def photon_energy(f, h=6.62607015e-34):\n    return h * f"
  },
  "potential_energy": {
    "description": "Calculate gravitational potential energy using PE = mgh (physics).",
    "code": "def potential_energy(m, g, h):\n    return m * g * h"
  },
  "power": {
    "description": "Calculate power using P = W / t (physics).",
    "code": "def power(work, time):\n    return work / time"
  },
  "power_without_pow": {
    "description": "Calculate power of a number without using ** or pow().",
    "code": "def power(base, exp):\n if exp == 0:\n return 1\n result = base\n for _ in range(exp - 1):\n result *= base\n return result"
  },
  "pretty_print_json": {
    "description": "Pretty print a dictionary as formatted JSON string.",
    "code": "import json\n\ndef pretty_print_json(data):\n    return json.dumps(data, indent=4)"
  },
  "prime_factorization": {
    "description": "Find the prime factorization of a number, returning a list of prime factors.",
    "code": "def prime_factorization(n):\n    factors = []\n    d = 2\n    while d * d <= n:\n        while n % d == 0:\n            factors.append(d)\n            n //= d\n        d += 1\n    if n > 1:\n        factors.append(n)\n    return factors"
  },
  "prime_numbers": {
    "description": "Find all prime numbers up to a given number using the Sieve of Eratosthenes.",
    "code": "def sieve_of_eratosthenes(n):\n primes = [True] * (n + 1)\n p = 2\n while p * p <= n:\n if primes[p]:\n for i in range(p * p, n + 1, p):\n primes[i] = False\n p += 1\n return [p for p in range(2, n + 1) if primes[p]]"
  },
  "random_enemy_spawn": {
    "description": "Generate random spawn coordinates for an enemy within bounds, useful for gaming.",
    "code": "import random\n\ndef random_enemy_spawn(max_x, max_y):\n    return (random.randint(0, max_x), random.randint(0, max_y))"
  },
  "random_string": {
    "description": "Generate a random string of specified length with letters and digits.",
    "code": "import random\n\ndef random_string(length):\n import string\n chars = string.ascii_letters + string.digits\n return ''.join(random.choice(chars) for _ in range(length))"
  },
  "rate_limiter": {
    "description": "Implement a simple rate limiter using timestamps.",
    "code": "import time\n\ndef rate_limiter(max_calls, period):\n    calls = []\n    def limiter():\n        now = time.time()\n        calls[:] = [t for t in calls if now - t < period]\n        if len(calls) >= max_calls:\n            return False\n        calls.append(now)\n        return True\n    return limiter"
  },
  "rate_of_reaction": {
    "description": "Calculate the rate of reaction using rate = delta_concentration / delta_time (chemistry).",
    "code": "def rate_of_reaction(delta_concentration, delta_time):\n    return delta_concentration / delta_time"
  },
  "read_file_line_by_line": {
    "description": "Read a file line by line.",
    "code": "with open('filename.txt', 'r') as file:\n for line in file:\n print(line.strip())"
  },
  "relativistic_mass": {
    "description": "Calculate relativistic mass using m = m0 / sqrt(1 - v^2/c^2) (physics).",
    "code": "def relativistic_mass(m0, v, c=3e8):\n    return m0 / (1 - (v * v) / (c * c)) ** 0.5"
  },
  "remove_duplicates": {
    "description": "Remove duplicates from a list while preserving order.",
    "code": "def remove_duplicates(my_list):\n seen = set()\n return [x for x in my_list if not (x in seen or seen.add(x))]"
  },
  "remove_punctuation": {
    "description": "Remove all punctuation from a string.",
    "code": "import string\n\ndef remove_punctuation(s):\n return s.translate(str.maketrans('', '', string.punctuation))"
  },
  "remove_vowels": {
    "description": "Remove all vowels from a string.",
    "code": "def remove_vowels(s):\n vowels = 'aeiouAEIOU'\n return ''.join(char for char in s if char not in vowels)"
  },
  "resistance": {
    "description": "Calculate resistance using R = V / I (physics, Ohm's Law).",
    "code": "def resistance(v, i):\n    return v / i"
  },
  "retry_function": {
    "description": "Retry a function a specified number of times with delay.",
    "code": "import time\n\ndef retry_function(func, retries=3, delay=1):\n for attempt in range(retries):\n try:\n return func()\n except Exception as e:\n if attempt == retries - 1:\n raise e\n time.sleep(delay)"
  },
  "retry_with_backoff": {
    "description": "Retry a function with exponential backoff on failure.",
    "code": "import time\n\ndef retry_with_backoff(func, retries=3, initial_delay=1):\n delay = initial_delay\n for attempt in range(retries):\n try:\n return func()\n except Exception as e:\n if attempt == retries - 1:\n raise e\n time.sleep(delay)\n delay *= 2"
  },
  "reverse_string": {
    "description": "Reverse a string.",
    "code": "reversed_str = my_string[::-1]"
  },
  "rotate_list": {
    "description": "Rotate a list by n positions to the left.",
    "code": "def rotate_list(lst, n):\n n = n % len(lst)\n return lst[n:] + lst[:n]"
  },
  "rotate_matrix": {
    "description": "Rotate a square matrix 90 degrees clockwise.",
    "code": "def rotate_matrix(matrix):\n    n = len(matrix)\n    return [[matrix[n-1-j][i] for j in range(n)] for i in range(n)]"
  },
  "run_in_parallel": {
    "description": "Run multiple functions in parallel using multiprocessing.",
    "code": "from multiprocessing import Pool\n\ndef run_in_parallel(func, args_list):\n with Pool() as pool:\n return pool.map(func, args_list)"
  },
  "sanitize_filename": {
    "description": "Sanitize a string to be a valid filename.",
    "code": "def sanitize_filename(s):\n import string\n valid_chars = string.ascii_letters + string.digits + '-_.'\n return ''.join(c if c in valid_chars else '_' for c in s)"
  },
  "series_resistance": {
    "description": "Calculate total resistance in a series circuit (physics).",
    "code": "def series_resistance(resistors):\n    return sum(resistors)"
  },
  "set_bit": {
    "description": "Set a specific bit in a number to 1, useful for low-level programming.",
    "code": "def set_bit(n, position):\n    return n | (1 << position)"
  },
  "shift_left": {
    "description": "Perform a left shift operation, mimicking assembly shift instructions.",
    "code": "def shift_left(a, n):\n    return a << n"
  },
  "shift_right": {
    "description": "Perform a right shift operation, mimicking assembly shift instructions.",
    "code": "def shift_right(a, n):\n    return a >> n"
  },
  "sign_extend": {
    "description": "Perform sign extension on a number from a given bit width to 32 bits, useful for low-level programming.",
    "code": "def sign_extend(value, bits):\n    sign_bit = 1 << (bits - 1)\n    return (value & (sign_bit - 1)) - (value & sign_bit)"
  },
  "simulate_register": {
    "description": "Simulate a simple register operation (add/subtract) for assembly-like behavior.",
    "code": "def simulate_register(value, operation, operand):\n    if operation == 'add':\n        return value + operand\n    elif operation == 'sub':\n        return value - operand\n    else:\n        raise ValueError('Operation must be add or sub')"
  },
  "singleton_pattern": {
    "description": "Implement the Singleton pattern in Python.",
    "code": "class Singleton:\n _instance = None\n def __new__(cls):\n if cls._instance is None:\n cls._instance = super(Singleton, cls).__new__(cls)\n return cls._instance"
  },
  "snake_to_camel": {
    "description": "Convert a snake_case string to camelCase.",
    "code": "def snake_to_camel(s):\n    return ''.join(word.capitalize() for word in s.split('_'))"
  },
  "solve_quadratic": {
    "description": "Solve a quadratic equation ax^2 + bx + c = 0 and return the roots.",
    "code": "def solve_quadratic(a, b, c):\n    discriminant = b * b - 4 * a * c\n    if discriminant < 0:\n        return None\n    sqrt_d = discriminant ** 0.5\n    return [(-b + sqrt_d) / (2 * a), (-b - sqrt_d) / (2 * a)]"
  },
  "sort_dict_list": {
    "description": "Sort a list of dictionaries by a specific key.",
    "code": "sorted_list = sorted(my_list, key=lambda x: x['key'])"
  },
  "split_string_chunks": {
    "description": "Split a string into chunks of a specified length.",
    "code": "def split_string_chunks(s, chunk_size):\n return [s[i:i + chunk_size] for i in range(0, len(s), chunk_size)]"
  },
  "strategy_pattern": {
    "description": "Implement a strategy pattern for interchangeable algorithms in OOP.",
    "code": "class Strategy:\n    def execute(self, a, b):\n        pass\n\nclass AddStrategy(Strategy):\n    def execute(self, a, b):\n        return a + b\n\nclass SubtractStrategy(Strategy):\n    def execute(self, a, b):\n        return a - b\n\nclass Context:\n    def __init__(self, strategy):\n        self._strategy = strategy\n\n    def execute_strategy(self, a, b):\n        return self._strategy.execute(a, b)"
  },
  "strip_comments": {
    "description": "Remove single-line comments from a Python code string.",
    "code": "def strip_comments(code):\n lines = code.split('\\n')\n return '\\n'.join(line for line in lines if not line.strip().startswith('#'))"
  },
  "swap_without_temp": {
    "description": "Swap two numbers without using a temporary variable, using XOR.",
    "code": "def swap_without_temp(a, b):\n    a = a ^ b\n    b = a ^ b\n    a = a ^ b\n    return a, b"
  },
  "time_execution": {
    "description": "Measure the execution time of a function.",
    "code": "import time\n\ndef time_execution(func, *args, **kwargs):\n start = time.time()\n result = func(*args, **kwargs)\n end = time.time()\n return result, end - start"
  },
  "toggle_bit": {
    "description": "Toggle a specific bit in a number (0 to 1 or 1 to 0), useful for low-level programming.",
    "code": "def toggle_bit(n, position):\n    return n ^ (1 << position)"
  },
  "unique_list_order": {
    "description": "Remove duplicates from a list while preserving order.",
    "code": "def unique_list_order(lst):\n seen = set()\n return [x for x in lst if not (x in seen or seen.add(x))]"
  },
  "url_decode": {
    "description": "URL-decode a string for processing web responses in mobile apps.",
    "code": "from urllib.parse import unquote\n\ndef url_decode(s):\n    return unquote(s)"
  },
  "url_encode": {
    "description": "URL-encode a string for safe web requests in mobile apps.",
    "code": "from urllib.parse import quote\n\ndef url_encode(s):\n    return quote(s)"
  },
  "validate_email": {
    "description": "Validate an email address using a simple regex pattern.",
    "code": "import re\n\ndef validate_email(email):\n pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n return bool(re.match(pattern, email))"
  },
  "validate_ip_address": {
    "description": "Validate an IPv4 address using regex.",
    "code": "import re\n\ndef validate_ip_address(ip):\n    pattern = r'^(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})$'\n    match = re.match(pattern, ip)\n    if not match:\n        return False\n    return all(0 <= int(octet) <= 255 for octet in match.groups())"
  },
  "validate_password": {
    "description": "Validate a password against common security requirements.",
    "code": "import re\n\ndef validate_password(password):\n    if len(password) < 8:\n        return False\n    if not re.search(r'[A-Z]', password):\n        return False\n    if not re.search(r'[a-z]', password):\n        return False\n    if not re.search(r'\\d', password):\n        return False\n    if not re.search(r'[!@#$%^&*(),.?\":{}|<>]', password):\n        return False\n    return True"
  },
  "validate_url": {
    "description": "Validate a URL using a regex pattern.",
    "code": "import re\n\ndef validate_url(url):\n    pattern = r'^(https?://)?([\\w\\-]+\\.)+[\\w\\-]+(/[\\w\\-./?%&=]*)?$'\n    return bool(re.match(pattern, url))"
  },
  "vector_cross_product": {
    "description": "Calculate the cross product of two 3D vectors, useful in mathematics and physics.",
    "code": "def vector_cross_product(v1, v2):\n    return [v1[1] * v2[2] - v1[2] * v2[1],\n            v1[2] * v2[0] - v1[0] * v2[2],\n            v1[0] * v2[1] - v1[1] * v2[0]]"
  },
  "vector_dot_product": {
    "description": "Calculate the dot product of two vectors, useful in mathematics and physics.",
    "code": "def vector_dot_product(v1, v2):\n    return sum(x * y for x, y in zip(v1, v2))"
  },
  "vector_magnitude": {
    "description": "Calculate the magnitude (length) of a vector, useful in mathematics and physics.",
    "code": "def vector_magnitude(v):\n    return sum(x * x for x in v) ** 0.5"
  },
  "vector_normalize": {
    "description": "Normalize a vector to unit length, useful in mathematics and physics.",
    "code": "def vector_normalize(v):\n    mag = sum(x * x for x in v) ** 0.5\n    if mag == 0:\n        raise ValueError('Cannot normalize a zero vector')\n    return [x / mag for x in v]"
  },
  "velocity": {
    "description": "Calculate final velocity using v = u + at (physics kinematics).",
    "code": "def velocity(u, a, t):\n    return u + a * t"
  },
  "wavelength": {
    "description": "Calculate wavelength using lambda = v / f (physics).",
    "code": "def wavelength(v, f):\n    return v / f"
  },
  "work_done": {
    "description": "Calculate work done using W = F * d * cos(theta) (physics).",
    "code": "def work_done(f, d, theta):\n    import math\n    return f * d * math.cos(math.radians(theta))"
  },
  "write_list_to_file": {
    "description": "Write a list of strings to a file.",
    "code": "with open('filename.txt', 'w') as file:\n for item in my_list:\n file.write(f\"{item}\\n\")"
  },
  "zip_directory": {
    "description": "Zip all files in a directory into a single zip file.",
    "code": "import os\n\ndef zip_directory(directory, zip_name):\n    import zipfile\n    with zipfile.ZipFile(zip_name, 'w', zipfile.ZIP_DEFLATED) as zipf:\n        for root, _, files in os.walk(directory):\n            for file in files:\n                zipf.write(os.path.join(root, file), os.path.relpath(os.path.join(root, file), directory))"
  }
}